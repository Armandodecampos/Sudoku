<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f4f8;
            margin: 0;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }

        .start-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 20px;
        }
        
        .start-screen h1 {
            color: #2c3e50;
            font-size: 2.5rem;
        }

        #start-button {
            background-color: #2ecc71;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #start-button:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        #start-button:active {
            transform: translateY(0);
        }

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between; /* Altera a justificação para espaçar os itens */
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }
        .top-bar h1 {
            margin: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            padding-top: 60px; /* Adiciona padding para evitar que o conteúdo fique atrás do top-bar */
            box-sizing: border-box;
            justify-content: center;
            align-items: center;
        }

        .sudoku-container {
            background-color: #ffffff;
            border-radius: 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: none;
            max-height: none;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        h1 {
            color: #2c3e50;
            margin: 0;
            font-weight: 700;
            font-size: 1.8rem;
        }

        canvas {
            border: 4px solid #34495e;
            border-radius: 8px;
            cursor: pointer;
            touch-action: none;
            max-width: 100%;
        }

        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 700;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }

        .message-box.visible {
            display: block;
        }
        
        .timer-display {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2c3e50;
        }

        .game-buttons-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap; 
            justify-content: flex-start;
            align-items: center;
        }

        .game-buttons-container button, .clear-btn, .notes-mode-btn {
            background-color: #2ecc71;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-buttons-container button.new-game {
            background-color: #e74c3c;
        }
        .game-buttons-container button.new-game:hover {
            background-color: #c0392b;
        }

        .game-buttons-container button.notes-mode-on {
            background-color: #3498db;
        }
        .game-buttons-container button.notes-mode-on:hover {
            background-color: #2980b9;
        }

        .game-buttons-container button:hover, .clear-btn:hover, .notes-mode-btn:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }
        
        .game-buttons-container button:active, .clear-btn:active, .notes-mode-btn:active {
            transform: translateY(0);
        }

        .input-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .number-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            flex-grow: 1; /* Permite que o teclado numérico ocupe o espaço restante */
        }

        .number-pad button {
            width: 50px;
            height: 50px;
            background-color: #ecf0f1;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
        }

        .number-pad button:hover {
            background-color: #e0e6e9;
            transform: scale(1.05);
        }

        .number-pad button:active {
            transform: scale(1);
        }
        
        .clear-btn, .notes-mode-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 15px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            height: 100px;
            width: 100px; /* Adiciona largura fixa para ambos os botões */
        }

        .clear-btn {
            background-color: #e74c3c;
        }

        .clear-btn:hover {
            background-color: #c0392b;
        }

        .clear-btn i {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .notes-mode-btn {
            background-color: #bdc3c7; /* Cor padr\u00e3o para desativado */
            color: #2c3e50;
        }
        
        .notes-mode-btn.active {
            background-color: #3498db; /* Cor para ativado */
            color: white;
        }
        
        .notes-mode-btn.active:hover {
            background-color: #2980b9;
        }

        .notes-mode-btn:hover {
            background-color: #95a5a6;
        }

        .notes-mode-btn i {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        /* Adiciona a animação de tremor */
        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }

        .shake {
            animation: shake 0.5s;
        }

        /* Layout para telas pequenas */
        @media (max-width: 600px) {
            .sudoku-container {
                padding: 15px;
            }
            .top-bar {
                flex-direction: column;
                height: auto;
                padding: 10px;
                align-items: center; /* Centraliza verticalmente */
                gap: 10px;
                justify-content: center; /* Centraliza horizontalmente */
            }
            .top-bar h1, .timer-display {
                margin: 0;
            }
            .game-buttons-container {
                margin-left: 0;
                justify-content: center; /* Centraliza horizontalmente */
                align-items: center; /* Centraliza verticalmente */
            }
            .number-pad button {
                width: 40px;
                height: 40px;
                font-size: 1.2rem;
            }
            canvas {
                width: 95vw; /* Ocupa 95% da largura da tela */
                height: 95vw;
            }
            .game-buttons-container {
                width: 100%;
                justify-content: space-around;
            }
        }
        
        /* Layout para telas grandes */
        @media (min-width: 800px) {
            .sudoku-container {
                flex-direction: row;
                align-items: center;
                justify-content: center;
                gap: 50px;
            }
            .input-controls {
                flex-direction: row;
                gap: 20px;
            }
        }
        
        .input-controls .clear-btn, .input-controls .notes-mode-btn, .input-controls .number-pad {
            order: 2;
        }
        
        .input-controls .clear-btn {
            order: 1;
        }
        
        .input-controls .notes-mode-btn {
            order: 3;
        }

        /* Estilo para o modal de confirmação */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 400px;
            text-align: center;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        .modal-buttons button {
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            border: none;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #confirm-solve, #confirm-new-game {
            background-color: #e74c3c;
            color: white;
        }
        #confirm-solve:hover, #confirm-new-game:hover {
            background-color: #c0392b;
        }
        #cancel-solve, #cancel-new-game {
            background-color: #bdc3c7;
            color: #2c3e50;
        }
        #cancel-solve:hover, #cancel-new-game:hover {
            background-color: #95a5a6;
        }
    </style>
</head>
<body>
    <div class="start-screen" id="start-screen">
        <h1>Sudoku</h1>
        <div class="difficulty-control" style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
            <label for="difficulty-select" style="font-size: 1.2rem; color: #34495e; font-weight: bold;">Escolha a Dificuldade:</label>
            <select id="difficulty-select" style="padding: 10px; border-radius: 8px; border: 2px solid #bdc3c7; font-size: 1rem;">
                <option value="easy">Fácil</option>
                <option value="medium" selected>Médio</option>
                <option value="hard">Difícil</option>
            </select>
        </div>
        <button id="start-button">Iniciar</button>
    </div>

    <div id="game-container" style="display: none;">
        <div class="top-bar">
            <span id="timer-display" class="timer-display">00:00</span>
            <div class="game-buttons-container">
                <button id="solve-button"><i class="fas fa-check"></i> <span>Resolver</span></button>
                <button id="new-game-button" class="new-game"><i class="fas fa-redo"></i> <span>Novo Jogo</span></button>
            </div>
        </div>
        <div class="sudoku-container">
            <canvas id="sudokuCanvas"></canvas>
            <div class="input-controls">
                <button class="clear-btn">
                    <i class="fas fa-eraser"></i>
                    Limpar
                </button>
                <div class="number-pad">
                    <button class="num-btn">1</button>
                    <button class="num-btn">2</button>
                    <button class="num-btn">3</button>
                    <button class="num-btn">4</button>
                    <button class="num-btn">5</button>
                    <button class="num-btn">6</button>
                    <button class="num-btn">7</button>
                    <button class="num-btn">8</button>
                    <button class="num-btn">9</button>
                </div>
                <button id="notes-mode-button" class="notes-mode-btn">
                    <i class="fas fa-pencil-alt"></i>
                    Anotar
                </button>
            </div>
        </div>
    </div>
    
    <div id="messageBox" class="message-box"></div>

    <!-- Modal de Confirmação para Resolver -->
    <div id="solveModal" class="modal">
        <div class="modal-content">
            <p>Você tem certeza que deseja resolver o Sudoku?</p>
            <div class="modal-buttons">
                <button id="confirm-solve">Sim</button>
                <button id="cancel-solve">Não</button>
            </div>
        </div>
    </div>

    <!-- Modal de Confirmação para Novo Jogo -->
    <div id="newGameModal" class="modal">
        <div class="modal-content">
            <p>Você tem certeza que deseja iniciar um novo jogo?</p>
            <div class="modal-buttons">
                <button id="confirm-new-game">Sim</button>
                <button id="cancel-new-game">Não</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('sudokuCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const newGameButton = document.getElementById('new-game-button');
        const solveButton = document.getElementById('solve-button');
        const notesModeButton = document.getElementById('notes-mode-button');
        const inputControls = document.querySelector('.input-controls');
        const clearButton = document.querySelector('.clear-btn');
        const timerDisplay = document.getElementById('timer-display');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.getElementById('game-container');
        const difficultySelect = document.getElementById('difficulty-select');
        const solveModal = document.getElementById('solveModal');
        const confirmSolveBtn = document.getElementById('confirm-solve');
        const cancelSolveBtn = document.getElementById('cancel-solve');
        const newGameModal = document.getElementById('newGameModal');
        const confirmNewGameBtn = document.getElementById('confirm-new-game');
        const cancelNewGameBtn = document.getElementById('cancel-new-game');
        
        const boardSize = 9;
        let board = [];
        let solution = [];
        let originalBoard = [];
        let selectedCell = { row: -1, col: -1 };
        let cellSize;
        let notesMode = false;
        let timerInterval;
        let startTime;

        // Funções para salvar e carregar o jogo
        function saveGame() {
            const gameState = {
                board: board,
                solution: solution,
                originalBoard: originalBoard,
                notesMode: notesMode,
                startTime: startTime
            };
            localStorage.setItem('sudokuGame', JSON.stringify(gameState));
        }

        function loadGame() {
            const savedState = localStorage.getItem('sudokuGame');
            if (savedState) {
                const gameState = JSON.parse(savedState);
                board = gameState.board;
                solution = gameState.solution;
                originalBoard = gameState.originalBoard;
                notesMode = gameState.notesMode;
                startTime = gameState.startTime;
                
                gameContainer.style.display = 'flex';
                startScreen.style.display = 'none';
                getCanvasSize();
                drawBoard();
                startTimer();
                notesModeButton.classList.toggle('active', notesMode);
                showMessage("Jogo carregado!");
            } else {
                startScreen.style.display = 'flex';
                gameContainer.style.display = 'none';
            }
        }

        // Função para obter o tamanho do canvas
        function getCanvasSize() {
            const container = document.querySelector('.sudoku-container');
            const size = Math.min(container.clientWidth, window.innerHeight * 0.7) - 40;
            canvas.width = size;
            canvas.height = size;
            cellSize = canvas.width / boardSize;
        }

        // Função para mostrar mensagens temporárias
        function showMessage(msg) {
            messageBox.textContent = msg;
            messageBox.classList.add('visible');
            setTimeout(() => {
                messageBox.classList.remove('visible');
            }, 2000);
        }

        // Função para gerar um tabuleiro de Sudoku completo
        function generateSudoku(difficulty) {
            board = Array.from({ length: boardSize }, () => Array.from({ length: boardSize }, () => ({ value: 0, notes: new Set() })));
            let tempBoard = Array.from({ length: boardSize }, () => Array(boardSize).fill(0));
            solveSudoku(tempBoard);
            solution = JSON.parse(JSON.stringify(tempBoard));
            
            // Define o número de células a remover com base na dificuldade
            let cellsToRemove;
            switch (difficulty) {
                case 'easy':
                    cellsToRemove = 30; 
                    break;
                case 'medium':
                    cellsToRemove = 50; 
                    break;
                case 'hard':
                    cellsToRemove = 60;
                    break;
                default:
                    cellsToRemove = 50; // Padrão
            }

            // Remove números para criar o jogo
            originalBoard = JSON.parse(JSON.stringify(solution));
            for (let i = 0; i < cellsToRemove; i++) {
                let row = Math.floor(Math.random() * boardSize);
                let col = Math.floor(Math.random() * boardSize);
                while (originalBoard[row][col] === 0) {
                    row = Math.floor(Math.random() * boardSize);
                    col = Math.floor(Math.random() * boardSize);
                }
                originalBoard[row][col] = 0;
            }

            // Preenche o tabuleiro de jogo
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    board[row][col].value = originalBoard[row][col];
                }
            }
        }

        // Verifica se uma solução é única
        function hasUniqueSolution(grid) {
            let count = 0;
            const solveCount = (currentGrid) => {
                if (count > 1) return;
                let emptyCell = findEmptyCell(currentGrid);
                if (!emptyCell) {
                    count++;
                    return;
                }
                const [row, col] = emptyCell;
                for (let num = 1; num <= 9; num++) {
                    if (isSafe(currentGrid, row, col, num)) {
                        currentGrid[row][col] = num;
                        solveCount(currentGrid);
                        currentGrid[row][col] = 0;
                        if (count > 1) return;
                    }
                }
            };
            solveCount(JSON.parse(JSON.stringify(grid)));
            return count === 1;
        }

        // Lógica para resolver o Sudoku (Backtracking)
        function solveSudoku(grid) {
            let emptyCell = findEmptyCell(grid);
            if (!emptyCell) {
                return true;
            }
            const [row, col] = emptyCell;
            
            const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            shuffleArray(numbers); // Mistura os números para gerar tabuleiros diferentes
            
            for (let num of numbers) {
                if (isSafe(grid, row, col, num)) {
                    grid[row][col] = num;
                    if (solveSudoku(grid)) {
                        return true;
                    }
                    grid[row][col] = 0;
                }
            }
            return false;
        }
        
        // Encontra uma célula vazia (valor 0)
        function findEmptyCell(grid) {
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (grid[row][col] === 0) {
                        return [row, col];
                    }
                }
            }
            return null;
        }

        // Verifica se é seguro colocar um número em uma célula
        function isSafe(grid, row, col, num) {
            // Verifica a linha
            for (let x = 0; x < boardSize; x++) {
                if (grid[row][x] === num) return false;
            }
            // Verifica a coluna
            for (let x = 0; x < boardSize; x++) {
                if (grid[x][col] === num) return false;
            }
            // Verifica o quadrado 3x3
            const startRow = row - row % 3;
            const startCol = col - col % 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] === num) return false;
                }
            }
            return true;
        }

        // Função para embaralhar um array (Fisher-Yates shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Desenha o tabuleiro no canvas
        function drawBoard() {
            // Verifica se o tabuleiro foi inicializado antes de tentar desenhá-lo
            if (!board || board.length === 0) {
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenha as linhas da grade
            ctx.lineWidth = 2;
            for (let i = 0; i <= boardSize; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
            }

            // Desenha as linhas grossas dos quadrados 3x3
            ctx.lineWidth = 4;
            for (let i = 0; i < boardSize; i += 3) {
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
            }

            // Desenha os números no tabuleiro e as anotações
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const cell = board[row][col];
                    const x = col * cellSize;
                    const y = row * cellSize;

                    // Verifica se a célula é preenchida pelo usuário e se está correta
                    if (cell.value !== 0 && originalBoard[row][col] === 0) {
                        if (cell.value === solution[row][col]) {
                            ctx.fillStyle = 'rgba(144, 238, 144, 0.4)'; // Verde claro
                        } else {
                            ctx.fillStyle = 'rgba(255, 182, 193, 0.4)'; // Vermelho claro
                        }
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }


                    if (cell.value !== 0) {
                        ctx.fillStyle = (originalBoard[row][col] !== 0) ? '#34495e' : '#2980b9';
                        ctx.font = `${cellSize * 0.6}px 'Inter', sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(cell.value, x + cellSize / 2, y + cellSize / 2);
                    } else if (cell.notes.size > 0) {
                        ctx.fillStyle = '#7f8c8d';
                        ctx.font = `${cellSize * 0.25}px 'Inter', sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const notesArray = Array.from(cell.notes).sort();
                        
                        let notesGrid = [
                            [1, 2, 3],
                            [4, 5, 6],
                            [7, 8, 9]
                        ];
                        
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                const num = notesGrid[i][j];
                                if (notesArray.includes(num)) {
                                    const noteX = x + (j * cellSize / 3) + cellSize / 6;
                                    const noteY = y + (i * cellSize / 3) + cellSize / 6;
                                    ctx.fillText(num, noteX, noteY);
                                }
                            }
                        }
                    }
                }
            }
            
            // Destaca a célula selecionada
            if (selectedCell.row !== -1 && selectedCell.col !== -1) {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.3)';
                ctx.fillRect(selectedCell.col * cellSize, selectedCell.row * cellSize, cellSize, cellSize);
            }
        }

        // Lidar com o clique do mouse
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {
                selectedCell = { row, col };
                drawBoard();
            }
        }
        
        // Lidar com o toque na tela
        function handleCanvasTouch(event) {
            event.preventDefault(); // Impede o comportamento de rolagem
            const rect = canvas.getBoundingClientRect();
            const touch = event.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {
                selectedCell = { row, col };
                drawBoard();
            }
        }

        // Lidar com a entrada de número
        function handleNumberInput(value) {
            if (selectedCell.row === -1 || selectedCell.col === -1) {
                showMessage("Selecione uma célula!");
                return;
            }
            
            const cell = board[selectedCell.row][selectedCell.col];

            // Não permite mudar os números originais do jogo
            if (originalBoard[selectedCell.row][selectedCell.col] !== 0) {
                showMessage("Você não pode alterar os números originais!");
                return;
            }
            
            if (notesMode) {
                // Adiciona/remove anotação
                if (cell.notes.has(value)) {
                    cell.notes.delete(value);
                } else {
                    cell.notes.add(value);
                }
            } else {
                // Preenche o valor principal
                cell.value = value;
                cell.notes.clear(); // Limpa as anotações ao preencher o valor principal
                checkWinCondition();
            }
            drawBoard();
            saveGame();
        }

        // Verifica a condição de vitória
        function checkWinCondition() {
            // Verifica se o tabuleiro está cheio
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col].value === 0) {
                        return; // O jogo ainda não terminou
                    }
                }
            }
            
            // Verifica se a solução é correta
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col].value !== solution[row][col]) {
                        showMessage("Ops, a solução está incorreta. Tente novamente!");
                        return;
                    }
                }
            }
            
            stopTimer();
            showMessage("Parabéns! Você resolveu o Sudoku!");
            localStorage.removeItem('sudokuGame');
        }

        // Função para lidar com a limpeza da célula
        function clearSelectedCell() {
            if (selectedCell.row === -1 || selectedCell.col === -1) {
                showMessage("Selecione uma célula!");
                clearButton.classList.add('shake');
                setTimeout(() => clearButton.classList.remove('shake'), 500);
                return;
            }

            const cell = board[selectedCell.row][selectedCell.col];
            const originalValue = originalBoard[selectedCell.row][selectedCell.col];

            if (originalValue !== 0) {
                showMessage("Você não pode limpar os números originais!");
                clearButton.classList.add('shake');
                setTimeout(() => clearButton.classList.remove('shake'), 500);
                return;
            }

            if (cell.value !== 0) {
                cell.value = 0;
            } else if (cell.notes.size > 0) {
                cell.notes.clear();
            } else {
                showMessage("A célula já está vazia!");
                clearButton.classList.add('shake');
                setTimeout(() => clearButton.classList.remove('shake'), 500);
                return;
            }
            
            drawBoard();
            saveGame();
        }

        // Funções do cronômetro
        function startTimer() {
            if (!startTime) {
                startTime = Date.now();
            }
            timerInterval = setInterval(() => {
                const elapsedTime = Date.now() - startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerDisplay.textContent = formattedTime;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Lógica para salvar o jogo ao sair ou recarregar a página
        window.addEventListener('beforeunload', saveGame);
        window.addEventListener('blur', saveGame);


        // Event listeners
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', handleCanvasTouch);

        inputControls.addEventListener('click', (event) => {
            const target = event.target.closest('button');
            if (target && target.classList.contains('num-btn')) {
                const value = parseInt(target.textContent);
                handleNumberInput(value);
            } else if (target && target.classList.contains('clear-btn')) {
                clearSelectedCell();
            } else if (target && target.id === 'notes-mode-button') {
                notesMode = !notesMode;
                notesModeButton.classList.toggle('active', notesMode);
                if (notesMode) {
                    showMessage("Modo Anotações Ativado");
                } else {
                    showMessage("Modo Anotações Desativado");
                }
            }
        });
        
        // Botão de resolver abre o modal de confirmação
        solveButton.addEventListener('click', () => {
            solveModal.style.display = 'flex';
        });

        // Eventos do modal
        confirmSolveBtn.addEventListener('click', () => {
            stopTimer();
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    board[row][col].value = solution[row][col];
                    board[row][col].notes.clear();
                }
            }
            drawBoard();
            showMessage("Tabuleiro resolvido!");
            solveModal.style.display = 'none';
        });

        cancelSolveBtn.addEventListener('click', () => {
            solveModal.style.display = 'none';
        });
        
        // Botão de novo jogo abre o modal de confirmação
        newGameButton.addEventListener('click', () => {
            newGameModal.style.display = 'flex';
        });

        // Eventos do modal de novo jogo
        confirmNewGameBtn.addEventListener('click', () => {
            stopTimer();
            gameContainer.style.display = 'none';
            startScreen.style.display = 'flex';
            newGameModal.style.display = 'none';
            localStorage.removeItem('sudokuGame');
        });
        
        cancelNewGameBtn.addEventListener('click', () => {
            newGameModal.style.display = 'none';
        });
        
        window.addEventListener('resize', () => {
            getCanvasSize();
            drawBoard();
        });

        // Adiciona funcionalidade do teclado
        document.addEventListener('keyup', (event) => {
            const key = event.key;
            if (key >= '1' && key <= '9') {
                handleNumberInput(parseInt(key));
            } else if (key === 'Backspace' || key === 'Delete') {
                clearSelectedCell();
            }
        });
        
        // Inicia o jogo
        startButton.addEventListener('click', () => {
            startScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            getCanvasSize();
            const difficulty = difficultySelect.value;
            generateSudoku(difficulty);
            drawBoard();
            startTimer();
            saveGame();
        });

        // Inicialização da tela
        window.onload = function() {
            loadGame();
        }
    </script>
</body>
</html>
